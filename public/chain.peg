/*
 * Timelion syntax parser
 */

{
  var functions = [];
}

start
 = tree:series+ {
  return {
    tree: tree,
    functions: functions
  }
 }

arg_list
 = first:argument rest:more_args* {
  return [first].concat(rest);
 }

more_args
 = ',' space? arg:argument {return arg;}

argument
 = arg_name:function_name '=' element:arg_type {
  return {
   type: 'namedArg',
   name:arg_name,
   value:element
  }
 }
 / element:arg_type {return element}

arg_type
 = series_type
 / literal

series_type
 = group
 / chain
 / reference

series
 = series:series_type ','? space? { return series }

function_name // check
 = (first:[a-zA-Z]+ rest:[a-zA-Z0-9_-]* ) { return first.join('') + rest.join('') }

function "function"
 = '.' name:function_name '(' space? arguments:arg_list? space? ')' {
  var result = {
    type: 'function',
    function: name,
    arguments: arguments || [],
    position: {
      min: offset(),
      max: offset() + text().length,
      text: text()
    }

  }

  functions.push(result)
  return result;
 }

reference
 = plot:integer ':' series:integer {
  return {
   type: 'reference',
   plot: plot,
   series: series
  }
 }

chain
 = func:function rest:function* {return {type: 'chain', chain: [func].concat(rest)}}
 / '.' func:function_name? {
  var exception = {
    type: 'incompleteFunction',
    function: func,
    position: {
      min: offset(),
      max: offset() + text().length,
      text: text()
    }
  }
  error(JSON.stringify(exception));
 }

group
 = '(' space? grouped:series+ space? ')' functions:function* {
  first = {
    type: 'chainList',
    list: grouped
  }
  first.label = text();

  return {type: "chain", chain: [first].concat(functions)};
 }

 /* ----- Core types ----- */

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^()"',=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so making a number rule
   // reads (and probably performs) worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t]+

dq_char
  = [\x20-\x21\x23-\x5B\x5D-\u10FFFF] // everything except "
  / "\\" sequence:('"' / "\\") { return sequence; }

sq_char
  = [\x20-\x26\x28-\x5B\x5D-\u10FFFF] // everything except '
  / "\\" sequence:("'" / "\\") { return sequence; }

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}