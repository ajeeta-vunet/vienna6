/*
 * Timelion syntax parser
 */

{
  var functions = [];
}

start
 = tree:series+ {
  return {
    tree: tree,
    functions: functions
  }
 }

arg_list
 = first:argument rest:more_args* {
  return [first].concat(rest);
 }

more_args
 = ',' space? arg:argument {return arg;}

argument
 = arg_name:function_name '=' element:arg_type {
  return {
   type: 'namedArg',
   name:arg_name,
   value:element
  }
 }
 / element:arg_type {return element}

arg_type
 = series_type
 / literal

series_type
 = group
 / chain
 / reference

series
 = series:series_type ','? space? { return series }

function_name // check
 = (first:[a-zA-Z]+ rest:[a-zA-Z0-9_-]* ) { return first.join('') + rest.join('') }

function "function"
 = '.' name:function_name '(' space? arguments:arg_list? space? ')' {
  var result = {
    type: 'function',
    function: name,
    arguments: arguments || [],
    position: {
      min: offset(),
      max: offset() + text().length,
      text: text()
    }

  }

  functions.push(result)
  return result;
 }

reference
 = plot:integer ':' series:integer {
  return {
   type: 'reference',
   plot: plot,
   series: series
  }
 }

chain
 = func:function rest:function* {return {type: 'chain', chain: [func].concat(rest)}}
/*
 / '.' func:function_name? {
  var exception = {
    type: 'incompleteFunction',
    function: func,
    position: {
      min: offset(),
      max: offset() + text().length,
      text: text()
    }
  }
  error(JSON.stringify(exception));
 }
*/

group
 = '(' space? grouped:series+ space? ')' functions:function* {
  first = {
    type: 'chainList',
    list: grouped
  }
  first.label = text();

  return {type: "chain", chain: [first].concat(functions)};
 }

 /* ----- Core types ----- */

literal "literal"
  = '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / string:[^()"',=\ \t]+ { // unquoted literal
   var result = string.join('');

   // This is all sort of hacky, but PEG doesn't have backtracking
   // and it feels cleaner than the alternatives

   if (result === 'null') return null;
   if (result === 'true') return true;
   if (result === 'false') return false;
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t]+

dq_char
  = [\x20-\x21\x23-\x5B\x5D-\u10FFFF] // everything except "
  / "\\" sequence:('"' / "\\") { return sequence; }


sq_char
  = [\x20-\x26\x28-\x5B\x5D-\u10FFFF] // everything except '
  / "\\" sequence:("'" / "\\") { return sequence; }

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}